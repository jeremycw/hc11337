            ORG	$0000
addrX	FCB	$00,$10	;ADDR OF THE FIRST NUMBER
addrY	FCB	$00,$20	;ADDR OF THE SECND NUMBER
addrZ	FCB	$00,$30	;ADDR OF THE RESULT
N	FCB	$00,$0A	;NUMBER OF BYTES IS TEN
	ORG	$0010
	FCB	$01,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$80
	ORG	$0020
	FCB	$01,$00,$00,$00,$00,$00,$00,$00,$00,$80
	ORG	$0030
	FCB	$99,$99,$99,$99,$99,$99,$99,$99,$99,$99

indexX	FCB	$00,$00
indexY	FCB	$00,$00
indexZ	FCB	$00,$00
counter FCB 	$00,$00

	ORG $C000
	LDX N
	PSHX
	LDX addrZ
	PSHX
	LDX addrY
	PSHX
	LDX addrX
	PSHX
	JSR S1
LUE	BRA LUE

	ORG $F000
CPUIMG	FCB $00,$00,$00,$00,$00,$00
PARAMS	FCB $00,$00,$00,$00,$00,$00,$00,$00
	;CREATE IMG OF THE CPU
S1	STX CPUIMG
	LDX #CPUIMG
	STAA 2,X
	STAB 3,X
	STY 4,X

	PULX ;TAKE PC OF THE STACK
	LDY #PARAMS
	;STORE ADDR1 TO MEM
	PULA
	PULB
	STD Y
	;STORE ADDR2 TO MEM
	PULA
	PULB
	STD 2,Y
	;STORE ADDR3 TO MEM
	PULA
	PULB
	STD 4,Y
	;STORE N TO MEM
	PULA
	PULB
	STD 6,Y

	PSHX ;PUT PC ON STACK

	LDX 6,Y
	STX counter

	LDD Y
	ADDD N
	SUBD #$01
	STD indexX

	LDD 2,Y
	ADDD N
	SUBD #$01
	STD indexY

	LDD 4,Y
	ADDD N
	SUBD #$01
	STD indexZ

	CLC


loop	LDX indexX
	LDAA 0,X
	LDX indexY
	ADCA 0,X
	LDX indexZ
	STAA 0,X

	LDX #indexX
	PSHX
	JSR S2

	LDX #indexY
	PSHX
	JSR S2

	LDX #indexZ
	PSHX
	JSR S2

	LDX #counter
	PSHX
	JSR S2

	BNE loop

	;RESTORE CPU REGISTERS
	LDX #CPUIMG
	LDAA 2,X
	LDAB 3,X
	LDY 4,X
	LDX X
	RTS

S2	PULX ;take the pc off the stack
	PULY ;take #N of the stack
	PSHX ;put the pc on the stack
	LDX Y ;load the value of N into x
	DEX ;decrement
	STX Y ;store the value to #N
	RTS ;return
